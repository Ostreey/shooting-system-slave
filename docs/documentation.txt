Interactive Shooting Targets System – Technical Documentation
##Overview
The interactive shooting targets system (code-named Aimora) is a multi-component setup designed for shooting practice and games. It consists of wireless electronic target units that detect hits and a companion mobile application that coordinates gameplay, scoring, and user interaction. The system allows users to set up multiple targets, connect them to a smartphone via Bluetooth, and engage in various training games (such as timed target shooting). When a target is hit, the impact is sensed and immediately communicated to the mobile app, which provides feedback to the shooter (both on-screen and via target-mounted LED indicators). This enables an interactive shooting experience suitable for safe training or recreational competition, with real-time scoring and performance metrics.
Key features of the system include: wireless operation (battery-powered targets communicating via Bluetooth Low Energy), real-time hit detection (with measurement of hit strength), visual feedback on each target (using LEDs that flash or change color on hits or status changes), and a user-friendly mobile app interface to configure games, display scores, and manage the target devices. The design emphasizes portability (targets are compact and untethered), flexibility in deployment (targets can be mounted using built-in magnets), and extensibility (multiple targets can be used together for complex scenarios). Overall, the system’s architecture is intended to be robust and scalable, allowing an AI or any user with access to the project files to understand how hardware and software components work together to create an interactive shooting range.
##System Components
The system is composed of both hardware and software components that work in unison. The primary components are:
## Target Sensor Units (ESP32-Based): These are the physical targets that detect shots. Each unit contains an ESP32 microcontroller, a piezoelectric impact sensor, indicator LEDs, and a battery with associated power circuitry. The target’s firmware handles hit detection and wireless communication with the mobile app.

## Mobile Application (Android): A smartphone app (developed in Kotlin) provides the user interface for the system. It allows users to connect to multiple target units, configure game modes (e.g. timed challenges), start/stop games, and view real-time feedback (hit count, hit strength, timers, etc.). The app communicates with the targets via Bluetooth Low Energy (BLE) and also manages higher-level game logic.

## Wireless Communication (BLE): The ESP32 targets act as BLE peripherals advertising a custom service, and the mobile app acts as a central client. This link carries hit event data and status information (like battery level) from each target to the app, and also carries control commands from the app to the targets (for example, to start a game or to power down the devices remotely).

## Power and Charging System: Each target unit is powered by a rechargeable Li-ion battery (14500 type cell). The target’s PCB includes power regulation (a step-up converter and a 3.3V linear regulator) to provide stable voltages for the microcontroller and sensors. There is also a provision for measuring battery voltage so the app can display the remaining battery level. The device can enter a low-power deep sleep mode to conserve energy, and a wake mechanism (e.g. a button or sensor trigger) is used to turn the target back on.

## Mounting and Enclosure: The target’s hardware is housed in a durable, 3D-printed plastic enclosure. The design includes magnets mounted in the enclosure (4 per target) which allow each target unit to be easily attached to metal surfaces for setup. This provides flexibility in arranging targets in different environments (e.g. mounting on a metal stand or a wall). The enclosure protects the electronics from impact and positions the piezo sensor behind the target strike surface.

## In summary, the system components integrate to form an interactive, wireless target training system: the ESP32-based target units handle sensing and immediate feedback, while the mobile app orchestrates the overall experience (device connectivity, game rules, and user feedback). The BLE wireless link is the backbone that enables these components to exchange data in real time. Below, each of the major components is described in more detail, including their architecture and role in the system.
## Target Sensor Unit (ESP32-Based Hardware)
## Each target unit is built around an ESP32 microcontroller mounted on a custom PCB. The ESP32 was chosen for its integrated Wi-Fi/Bluetooth capabilities and sufficient processing power to handle sensor data in real time. In this project, the ESP32 operates primarily in Bluetooth Low Energy (BLE) mode to communicate with the mobile app. The microcontroller firmware is responsible for reading the sensor, detecting hits, controlling LEDs, and managing the BLE communication.
## Impact Sensor (Piezoelectric): To detect a hit, the target uses a piezoelectric sensor attached to the target plate or embedded in the device. When the target is struck (for example, by a projectile or a physical impact), the piezo sensor generates a voltage spike. The ESP32’s analog-to-digital converter (ADC) reads the piezo sensor’s signal (on an analog input pin). The firmware continually samples this analog input in a fast loop (using a dedicated task on the ESP32) and applies a threshold-based detection. If the analog reading exceeds a predefined threshold (indicating a sufficiently strong impact), the system registers a “hit.” A debounce mechanism in software ignores rapid successive triggers from the same hit – for example, the firmware imposes a short 200 ms lockout after a detected hit to avoid double-counting. The threshold is calibrated such that minor vibrations or noise are ignored, while real hits (from a BB, airsoft pellet, Nerf dart, or other projectile) are reliably detected. When a hit is confirmed, the firmware records the peak sensor value (as an indicator of hit strength) and triggers a notification event.
## Wireless Communication (BLE Characteristics): On each target, the ESP32’s firmware runs a BLE server (advertised under the name “SHOOTING TARGET” in this implementation). A custom BLE service (UUID 91bad492-b950-4226-aa2b-4ede9fa42fff) is used to expose data and receive commands relevant to the target’s operation. Within this service, there are at least two primary BLE characteristics:
## A Hit Data Characteristic (cba1d466-344c-4be3-ab3f-189f80dd75ff) for reporting hit events. When the piezo sensor registers a hit, the ESP32 writes the measured value (hit strength) to this characteristic and sends a BLE notification to the connected app. This allows the mobile application to instantly know which target was hit and how strong the impact was. The value could be a raw ADC reading or a processed number representing the force of the hit.

## A Battery Level Characteristic (cba1d466-344c-4be3-ab3f-189f80dd76ff) for reporting the target’s battery status. The ESP32 periodically measures the battery voltage via an analog input (through a resistor divider circuit to step the voltage down to a measurable range). Using the ESP32’s ADC calibration utilities, the firmware converts this reading into a battery level or voltage. The value is then updated on the battery characteristic so the app can read it. The app typically polls or subscribes to this characteristic to display each target’s battery level in its UI. This ensures the user is aware of when a target’s battery is getting low.

## Additionally, the target firmware and app support a control mechanism via BLE. For example, the app can send a command to put the target into a sleep state (powering it down remotely). This is implemented by the target listening for a specific write or value on one of the BLE characteristics or a dedicated control characteristic (the project defines an OTA service as well, discussed below). When the user taps “Turn off targets” in the app, a command is sent to each connected device, upon which the ESP32 executes a shutdown sequence: it might flash an LED or log a message (e.g. “Going to deep sleep...”) and then enter deep sleep mode. In deep sleep, the device draws minimal power; the microcontroller can only be woken by a designated wake-up source (in this design, a wake button or trigger is connected to an RTC GPIO for wake-up). The hardware uses GPIO15 as a wake input (for example, a push-button tied to that pin) – pressing the button or perhaps tapping the target (if the piezo is also wired to wake) will wake the ESP32 from deep sleep.
## LED Indicators: Each target unit features multiple LED indicators to provide visual feedback. According to the PCB design, there are three colored LEDs (blue, green, and red) on each target’s circuit. These are likely used to convey different states:
## The Blue LED could indicate connectivity status (e.g. blinking during Bluetooth pairing or staying lit when the target is connected to the app).

## The Green LED might indicate a successful hit (flashing briefly when the target is struck) or an “active/ready” status during a game.

## The Red LED could serve as a warning (for example, low battery alert) or be used in certain game modes to signal a “no-shoot” target, etc. (The exact usage can be configured in software.)

## To conserve power, the LEDs might be disabled when not needed. The hardware includes a MOSFET or transistor (controlled by an ESP32 GPIO, labeled ledPowerEnable on the PCB) that can cut off power to the LED circuits. The firmware enables this when it wants to light the LEDs. For instance, when a hit is detected, the firmware could enable LED power and turn the green LED on for a short duration to acknowledge the hit, then turn it back off. This design lets the system have bright visible indicators without constantly draining the battery when the device is idle.
## Power Supply: Portability is achieved via a single-cell Li-ion 3.7 V battery (type 14500, ~750 mAh) in each target. The target’s PCB has a power regulation stage: a buck (step-down) regulator or LDO (e.g. HT7833) provides a stable 3.3 V for the ESP32 and other low-voltage components. Additionally, a boost converter (using an MT3608 DC-DC converter IC with an inductor and diode) is part of the design. The boost converter likely steps the battery voltage up to 5 V for certain components or for charging purposes. One possible use of the boosted 5 V rail is to drive high forward-voltage LEDs or to ensure the ESP32 can run even as the battery voltage drops near 3 V (since the ESP32’s regulator needs some headroom). The exact power topology is that the battery feeds into a power management circuit: there is a diode and 3.3 V zener diode in the design, which suggests over-voltage protection (the zener could clamp spikes, for instance from the piezo sensor). The HT7833 LDO regulator then outputs 3.3 V for the digital logic. The MT3608 boost converter, if used, likely creates a 5 V line when needed (it might be enabled only when LEDs are on, or it could be an always-on 5 V for the ESP32 if they chose a boost-buck arrangement – but typically the ESP32 can run from the Li-ion directly through the LDO). There is no dedicated charging IC listed in the BOM, which implies that the battery may be intended to be charged outside the device (i.e. the user swaps or charges the 14500 cells separately). Alternatively, the presence of the boost converter might relate to a charging circuit (for instance, some designs use a boost converter for charging a single cell from a 5 V USB input, though that would be unconventional without a charge controller). In any case, the device’s battery voltage is monitored by the ESP32 (through a resistor divider to pin GPIO33) to allow the system to report battery status and possibly to trigger the red LED or alerts when the battery is low.
## Firmware and OTA Updates: The ESP32 firmware (located in the shooting-system-slave source archive) not only handles real-time tasks (hit sensing, BLE communication) but also includes support for over-the-air updates. A secondary BLE service is dedicated to OTA firmware transfer (with its own UUIDs for an OTA control and data characteristic). The app can enter a firmware update mode, during which it uses the BLE OTA service to send a new firmware binary to the ESP32 (the ESP32’s firmware uses the Arduino OTA Update library to receive and flash this data). This allows the system to be updated without physically accessing the target devices, which is important for refining the system or adding features over time. The OTA process would typically involve the device resetting into a special mode to accept the new firmware and then restarting with the updated code.
## In summary, the target sensor unit is a self-contained module combining sensing, processing, communication, and feedback capabilities:
## It detects hits using a piezo sensor and threshold logic.

## It communicates hits and status to the app via BLE (using custom GATT characteristics for hit data and battery level).

## It provides visual/audible feedback (visual via LEDs, and a buzzer could be added using the piezo itself as a speaker, though currently the design focuses on LEDs).

## It manages power to operate on battery, including sleep modes and battery monitoring.

## It can be mounted easily and withstand repeated hits due to a sturdy enclosure and internal components like the shock-mounted piezo and protected circuitry.

## Mobile Application (Android)
## The mobile app is the control center for the interactive target system. It is an Android application (written in Kotlin) that provides an intuitive user interface and performs all high-level coordination between the user and the target hardware. The app’s primary responsibilities include: discovering and connecting to target units, displaying target status (battery, connectivity), configuring game settings, starting and stopping game sessions, handling incoming hit data in real time, and providing a visual scoreboard or feedback to the user. The source code for the app is contained in the aplikacja-mobilna archive, with a structure indicating an MVVM architecture (with components like MainActivity, view models, and repository classes for BLE operations).
## User Interface and Workflow: The app UI is organized into multiple screens corresponding to the setup and gameplay flow. The major screens are:
## Connect Targets Screen: This is where the user pairs the phone with the target units. On this screen (titled “Połącz cele”, meaning "Connect targets"), the app scans for available BLE devices advertising the “SHOOTING TARGET” service. The user can specify the number of target devices they intend to use (for example, 3 targets) and initiate the connection process. Each discovered target, once connected, is listed with an identifier (e.g. “Cel 1”, “Cel 2” meaning Target 1, Target 2) and its status. In the Connect Targets interface shown above, the user has requested 3 devices and the app has connected two so far (“Cel 1” and “Cel 2” are shown as Połączono – connected). A progress indicator or status is shown for each target as it connects. The app also displays a “Wyłącz cele” (“Turn off targets”) button, which when pressed will send a command to all connected targets to power them down. Once the desired number of targets are connected, the user proceeds by tapping “Dalej” (“Next”) to continue to game setup. (Note: The use of a specified number of devices ensures the app knows how many targets to look for and when the connection process is complete.)

## Game Selection Screen: After connecting the targets, the user is taken to the game selection interface. In the Game Selection screen illustrated above, the user can choose a game mode and view the connected targets’ battery status. At the top is a title (e.g., “Wybierz grę” – “Choose game”) and a dropdown or list of game modes. In the screenshot, “Gra na czas” (“Time trial game”) is selected, indicating a game where the goal might be to score as many hits as possible within a set time. Below the mode selection, the app displays icons for each connected target along with their battery levels (for instance, two target icons are shown, with battery indicators at 42% and 83%). This live battery info comes from the BLE battery characteristic on each device. There is an option to toggle advanced settings (the link “Pokaż ustawienia zaawansowane”), which likely reveals additional configuration (such as enabling/disabling certain targets or adjusting sensor sensitivity, etc.). Once the game mode is selected and any advanced settings are adjusted, the user can press “Rozpocznij” (“Start”) to move to game configuration or directly start if minimal setup is needed.

## Game Configuration Screen: For certain game modes, the app will prompt for specific parameters before starting the game. In the Game Configuration screen above (for the “Gra na czas” mode), the user can set parameters like the game duration in seconds. For example, the screenshot shows “Czas gry (s)” set to 10 seconds for a timed game. This screen also shows a brief description or icon for the chosen mode (and possibly a “Game rules” info icon for reference). After adjusting settings, the user taps “Start” to begin the game countdown.

## Gameplay (Live Game) Screen: During an active game, the app switches to a live monitoring screen that provides real-time feedback on the ongoing session. The Gameplay screen (for a time trial game) is shown above. At the top, a timer displays the remaining time or elapsed time (e.g., “Time: 1 s” in the screenshot, which might indicate one second has passed or remains). A progress bar may visualize the time left in a timed game. Below the timer, the score or hit count is shown (“Trafienia: 2” meaning “Hits: 2”, indicating the player has hit targets twice so far). Additionally, the screen features representations of each target: in the example, two target icons are displayed side by side. Each target icon can show dynamic information:

## A highlight or outline to show which target was hit last (the second target is highlighted in green in the image, indicating it registered the most recent hit).

## A readout of “Siła strzału” (“Shot strength”) with a numeric value for each hit. In the screenshot, Target 1 shows 592 and Target 2 shows 751 – these numbers correspond to the raw or scaled values from the piezo sensor, essentially quantifying how hard each target was hit. This gives the shooter immediate feedback on shot placement and force.

## Possibly an indicator if a target is currently active/inactive depending on game mode (for example, some games may have only one target active at a time).
During gameplay, each time a target sends a hit notification via BLE, the app increments the hit counter, logs the strength value, and updates the UI (highlighting the appropriate target icon and displaying the value). The app may also play a sound or use the phone’s vibration for additional feedback (though not shown, this can be easily added to enhance immersion). If multiple targets are used, the app keeps track of each individually, allowing for competitive or scenario-based games (e.g., which target was hit how many times).

## Post-Game and Additional Features: After the timer ends (or the game condition is met), the app would typically show the final results – for instance, total hits scored, maybe a breakdown by target, and possibly historical best scores. Though not explicitly shown in the provided UI screenshots, a results or summary screen is a logical component of the app. The app might also allow saving game data or switching to a different game mode to continue. Furthermore, the mobile application likely includes settings for device management (e.g., checking for firmware updates for the targets, calibrating sensors if needed, etc.). Since the app has an OTA updater module (Esp32OtaUpdater.kt is part of the source), there may be a feature where the user can update the firmware of the connected target units from within the app. This would involve selecting a firmware file or initiating an update process that transfers the new firmware to the targets via BLE.

## Bluetooth Low Energy Integration: Under the hood, the app uses Android’s BLE APIs to connect to each target. The code includes a BleClient class and a TargetRepositoryImpl that manage the BLE GATT connections. For each target device:
## The app scans for advertisements and identifies devices by the expected service UUID (91bad492-...).

## It connects and discovers the GATT services. Once connected, the app subscribes to notifications on the Hit Data characteristic for each device. This means whenever the target pushes a hit event, the app immediately receives it in a callback (the BleClient implements a BluetoothGattCallback to handle these events).

## The app also reads or subscribes to the Battery characteristic to get battery updates. In practice, it might poll the battery level at intervals rather than rely on notifications (depending on how the firmware is set—if the battery char has Notify property or just Read).

## To implement the “turn off targets” function, the app likely writes a specific value to a control characteristic or perhaps a special command on one of the existing characteristics. The target’s firmware interprets this and enters deep sleep. The app then closes the BLE connection to that device.

## The mobile app architecture (from the source structure) suggests a clean separation of concerns:
## UI is built with Android Jetpack Compose (the presence of composable functions like TargetView.kt, TargetsListView.kt, etc., indicates a modern Compose UI). This results in a responsive and flexible interface that can easily show lists of targets and update the UI state based on live data.

## A MainViewModel likely holds the state of connected targets and game progress, updating the UI as data changes (hits, timer countdown, etc.).

## A repository handles the BLE operations. This likely emits events (using Kotlin flows or LiveData) that the view model observes, converting them into UI state.

## The app also manages Bluetooth permissions and ensures the user’s device has Bluetooth on, etc., showing prompts if needed.

## From a usability standpoint, the mobile app is designed to be straightforward so that a user (or even an AI agent with access to it) can quickly get the system running:
## Setup: Turn on the target units (they start advertising via BLE). Open the app and go to Connect Targets, specify how many targets to link, and connect them one by one (the app handles scanning and pairing automatically).

## Configure Game: Choose a game mode and parameters. The app shows which targets are connected and their battery levels for confidence that everything is ready.

## Play: Start the game. The app provides a countdown (if needed) and then live feedback as the user shoots at the targets. Hits are counted and displayed instantly.

## Finish: When the game ends, review the performance and, if desired, save results or attempt another round. If done, use the app to turn off the targets to conserve their batteries.

## Because the documentation audience includes an AI model with access to project files, it’s noteworthy that the UI screenshots and code provide a clear mapping from conceptual components to implementation. For instance, the Connected Targets list in the UI corresponds to the list of BLE devices managed by the app’s BleClient and shown via a composable TargetsListView. Each hit strength displayed corresponds to data coming from the BLE notifications (handled in BleClient and propagated through the BleEvent data model to the UI). This modular design in code makes it easier to maintain and modify the app for future games or additional target types.
## PCB Design
## The Printed Circuit Board (PCB) for the target sensor unit integrates all the necessary electronics in a compact form factor. The PCB schematic (provided in the schemat_pcb.zip archive) is organized into sections corresponding to different functional blocks of the circuit:
## Main Controller Section: This part of the schematic includes the ESP32 microcontroller (likely an ESP32-WROOM module or similar) and its supporting components (such as its 3.3 V power input, enable pin, boot mode configuration resistors, and possibly a USB-UART interface if programming or debugging via USB is supported). The main section also includes the power management circuits, since those tie directly into the ESP32’s supply. For example, the HT7833 regulator is shown here, providing 3.3 V to the ESP32 from the battery source. Any necessary decoupling capacitors and reset circuitry are present as well. The ESP32 module’s GPIOs are routed to various parts of the board: one analog input is routed to the piezo sensor circuit (GPIO32 in this design), another analog input (GPIO33) is routed to a voltage divider from the battery (for battery measurement), digital outputs go to the LEDs (GPIO17,18,19 for Blue, Green, Red LEDs respectively), a GPIO (GPIO4) controls the LED power MOSFET, and a GPIO (GPIO15) is used for the wake button input (also note: GPIO15 is one of the ESP32’s RTC-capable pins, which is necessary for it to serve as a deep sleep wake-up source). The Main schematic likely also shows a programming header or goldpin connectors (3× goldpin listed in BOM) used for flashing the firmware onto the ESP32 during assembly (commonly exposing TX0, RX0, IO0, EN, 3.3 V, GND).

## Piezo Sensor Interface: The piezo sensor is a transducer that, when flexed or struck, generates a voltage. This portion of the PCB schematic shows the piezo element connected to the ESP32’s analog input through a resistor network. Typically, a high-value resistor (to ground) is used to bias or discharge the piezo and define a baseline. The design also includes a 3.3 V zener diode across the piezo input, which serves to clamp any voltage spikes to about 3.3 V – this is critical because a piezo can produce a brief high voltage (potentially tens of volts) when sharply struck. The zener (along with perhaps a series resistor or the input impedance of the ADC) protects the ESP32’s GPIO from exceeding its maximum voltage. The schematic sheet named “Piezo_sensor” likely details this, showing the piezo sensor connected through the protective components into an ADC pin on the ESP32. It may also illustrate the debounce capacitor (if one is used to smooth out the signal) – though in this case, the debounce is largely handled in software, a small capacitor might still be present to filter high-frequency noise.

## LED Driver Section: The “LEDS” schematic sheet contains the LED indicators and their driving circuitry. There are three LEDs (Blue, Green, Red), each presumably with a current-limiting resistor. Rather than connecting directly to the 3.3 V supply, these LEDs appear to be powered via a switched line controlled by ledPowerEnable (GPIO4). The schematic likely shows a PNP transistor or P-channel MOSFET as a high-side switch that connects the LED common anode to the battery (or boosted 5 V) when enabled. Each LED’s cathode would then connect to an ESP32 GPIO through a resistor (the ESP32 pins sink current to light the LEDs). This way, when ledPowerEnable is turned OFF (low), the LEDs have no supply and are fully off, drawing zero current; when it’s ON, the LEDs can light under control of their respective GPIO pins. The LED section might also include connectors or test points if the LEDs are physically off-board (but since it’s an integrated target, likely the LEDs are soldered on the PCB itself, facing outward through the enclosure).

## Power Supply Section: The PCB incorporates both boost and linear regulators. The MT3608 boost converter circuit is shown with its key components: an inductor (the coil listed in the BOM), a diode (likely a Schottky diode for the boost converter’s switching node), and feedback resistors that set the output voltage. The boost converter likely takes the battery (which ranges from ~4.2 V down to ~3.0 V) and boosts it to a stable 5 V output. The reasons for having a 5 V rail could include powering an off-the-shelf sensor or module that needs 5 V, or ensuring LED brightness (if the LEDs were high forward-voltage or in series), or to provide a stable voltage for analog reference. It’s possible that initially the design considered powering the ESP32 via 5 V and then using the HT7833 to regulate down to 3.3 V (since the ESP32 DevKit boards often use a similar approach when USB 5 V is available). If so, the battery would feed into the boost converter to make 5 V, then the HT7833 would create 3.3 V from that 5 V – ensuring the ESP32 always sees 3.3 V even when the battery is low. However, this double conversion has efficiency costs, so the design might instead only activate the boost when needed (e.g., for LEDs or during charging). The BOM doesn’t list a USB port or charging IC, so the boost converter might not be for charging, but the presence of it indicates careful power design. The HT7833 regulator is straightforward: it takes the higher voltage (battery or boosted) and provides a clean 3.3 V output for the ESP32 and other 3.3 V components. The power section also includes the battery itself (with a connector or solder pads) and possibly a protection circuit for the Li-ion cell (some designs include a battery protection IC to prevent over-discharge; not listed in BOM explicitly, so it might rely on the cell’s internal protection if it’s a protected 14500 cell). Goldpin connectors might be present for connecting an external battery charger or for measuring current during development.

## Miscellaneous: The PCB likely has a push-button (the “WiFi button” on GPIO15) placed somewhere accessible on the device. In the schematic, that would be depicted as a momentary switch between GPIO15 and ground (assuming it wakes on a LOW signal). There might also be a second button or a switch for manual power (though none is listed, deep sleep is used instead). If the WiFi button is multi-purpose, the firmware could use it for entering a WiFi config mode (given WiFiManager is in code, perhaps if this button is held on boot, the device might start WiFi AP for configuration – a feature that could be in development or left for future use). The PCB also breaks out some programming pins; these were counted as part of the BOM (3× goldpin, possibly a 3-pin header for UART or a 6-pin for full programming). There may be an LED on the board for power indication (not explicitly mentioned, but sometimes a small power LED is present).

## Physically, the PCB is sized to fit into the 3D-printed enclosure. The inclusion of magnets in the BOM implies the PCB or enclosure has slots for four magnets – likely at the corners or edges of the target – allowing it to snap onto a metal surface or a mounting plate. The PCB would be mounted securely inside the enclosure so that vibrations from hits transfer to the piezo sensor but not so much to damage the electronics. Connectors (if any, e.g., for the battery or for debugging) are placed for accessibility. The design likely underwent considerations for durability: for instance, the piezo sensor could be glued or clamped in a way that it reliably picks up hits without breaking. The “Wytrzymały plastik” (durable plastic) note suggests the material and construction of the enclosure/PCB combination can withstand repeated impacts.
## In conclusion, the PCB design ties together the microcontroller, sensor, power, and indicator subsystems in a compact layout. It reflects a balance between functionality and cost:
## By using mostly discrete components (instead of expensive modules), the hardware cost is kept low.

## The use of common, inexpensive parts (e.g., generic boost converter MT3608, a simple linear regulator, standard LEDs, and a readily available ESP32 module) makes the design reproducible and scalable.

## The schematic separation into logical sections aids understanding – one can see each function (sensing, indication, power) in isolation, which is helpful for debugging or future modifications (for example, upgrading the sensor or adding a different indicator would involve primarily its section of the schematic).

## Anyone reviewing the PCB files along with this documentation should gain a clear picture of how the hardware operates: the piezo sensor feeds into analog pin through a protective network, the ESP32 runs the show at 3.3 V, the battery and regulators provide the necessary power rails, and the BLE radio on the ESP32 connects everything to the outside world via the mobile app.
## Bill of Materials
## The Bill of Materials (BOM) for one target unit enumerates all the parts required to build the device, along with their quantities and cost estimates. According to the provided cost breakdown, the total production cost for a single target (including components, PCB fabrication, 3D printing, and assembly labor) is approximately 124 PLN (Polish Złoty) per unit. Below is an overview of the key components and their roles in the system:
## Custom PCB – 1 unit. This is the printed circuit board that all components are mounted on. (Cost in prototype quantities was about 15.66 PLN each including manufacturing and shipping for a batch of 20.)

## ESP32 Microcontroller Module – 1 unit. The brains of the target, providing microprocessing and Bluetooth connectivity. (Approx cost ~10.8 PLN.) The ESP32 module typically comes with a durable metal or plastic shielding can for RF compliance and protection.

## Piezoelectric Sensor – 1 unit. Acts as the hit detector by generating a voltage when the target is struck. This is usually a small disc that can be adhered to the target plate.

## 14500 Li-Ion Battery (3.7 V, 750 mAh) – 1 unit. Provides power to the target unit, rechargeable. (Rough cost ~6.8 PLN.) The battery is a cylinder shape (about AA-size) that fits into the enclosure.

## DC-DC Boost Converter (MT3608 chip + Inductor + Diode) – 1 set. Steps up the battery voltage to 5 V when needed. This consists of the MT3608 regulator IC, an inductor (cewka), and a Schottky diode, along with a few resistors/capacitors (small passive components not individually listed in the summary). The combined cost of these components is very low (each on the order of 0.1–0.5 PLN).

## 3.3 V LDO Regulator (HT7833) – 1 unit. Provides a stable 3.3 V supply for the ESP32 from the battery or boosted voltage. Cost was estimated at 0.4 PLN.

## 3.3 V Zener Diode – 1 unit. Protects the analog input (and generally the circuit) from over-voltage, particularly due to the piezo sensor’s spikes. Cost ~0.4 PLN.

## LED Indicators – 3 units (one each of Red, Green, Blue). These LEDs provide visual feedback to the user. In the BOM summary they are grouped as a single line item “ledy” (LEDs) with cost ~1 PLN for the set. Each LED likely includes a current-limiting resistor on the PCB (resistors are not listed individually but are part of the PCB assembly).

## Magnets – 4 units. Small magnets used for mounting the target to metal surfaces. Four magnets per target allow secure attachment; the BOM lists 4 magnets totaling ~2 PLN. These are likely neodymium magnets embedded in the enclosure.

## Battery connector and wiring – e.g., a set of battery cables – 1 unit. A small wire harness that connects the battery to the PCB (if the battery isn’t soldered directly). Cost negligible (~0.2 PLN).

## Pin Headers (Goldpin) – 3 units. These are likely 3 header pins used for programming or debugging connections on the PCB. They could also serve as connectors for the battery or other peripherals during assembly. Cost ~0.6 PLN total.

## Miscellaneous Components: This includes resistors, capacitors, and possibly a push-button switch (the “wifiButton”) and any other small hardware. These were not individually listed in the cost breakdown, presumably because their cost impact is minimal or they were accounted for in aggregate. However, they are crucial for the circuit’s function (e.g., resistors for the piezo sensor bias, LED current limiting, battery voltage divider; capacitors for power smoothing; a momentary push-button for wake; etc.).

## Enclosure (3D-Printed Housing) – 1 unit. The case is custom 3D printed in durable plastic. The BOM describes the printing cost assumptions: about 50 g of material and 2 hours of print time per enclosure, plus labor to supervise the print. This was estimated at 25 PLN per unit. The enclosure not only holds all components but also protects them and provides a user-friendly exterior (with holes for LEDs, button, perhaps a slot for charging or battery access, etc.).

## Assembly Labor – The BOM allocates an estimated labor cost (labeled “moja praca”, i.e., “my work”) of 60 PLN per target for the assembly and any manual work. This covers the time to solder components, assemble the device, and test it. While not a part component, it’s included to reflect the true cost of producing the unit.

## The overall BOM shows a focus on low-cost, readily available parts to keep the per-unit cost reasonable, considering this is likely a prototype/small-scale production. An interesting note is the absence of a dedicated charging circuit in the listed parts, implying a deliberate decision to simplify the design (possibly to avoid the complexities of charging circuitry and certifications – instead relying on external chargers or battery swapping). The costliest single item apart from labor is the 3D-printed enclosure (in terms of material and time). If scaled to mass production, that enclosure might be injection molded which would dramatically reduce its per-unit cost after initial tooling. The electronic components themselves (ESP32 module aside) are very inexpensive, each often under 1 PLN, which is advantageous for scaling up the number of targets.
## For an AI model or developer reviewing this project, the BOM provides insight into which hardware pieces are involved and their relative importance:
## It confirms the use of an ESP32 and a piezo sensor (core of the functionality).

##I t highlights the inclusion of power management parts (regulators and converter) that one should be mindful of when understanding the circuit behavior.

## It shows LEDs and magnets which inform the physical user experience (feedback and mounting).

## And it quantifies the material vs. labor effort, emphasizing that while the electronics are affordable, assembling and printing enclosures is a significant part of the project’s effort.

## In conclusion, the Bill of Materials underlines that each target unit is a blend of hardware disciplines: electronics, power, mechanics (enclosure), and firmware. All these components come together to achieve the interactive functionality of the system. The documentation and project files combined give a complete picture: from high-level operation down to each resistor on the board – providing a new AI model or team member all the information needed to fully understand and potentially recreate or modify the interactive shooting targets system.